<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="access_denied" xml:space="preserve">
    <value>Non ti è permesso di scrivere determinata destinazione. Si prega di scegliere un'altra cartella di destinazione.</value>
  </data>
  <data name="add_self_joining" xml:space="preserve">
    <value>Aggiungi un eseguibile self-join</value>
  </data>
  <data name="application_paused" xml:space="preserve">
    <value>L'applicazione è in pausa. Sei sicuro di voler uscire?</value>
  </data>
  <data name="bigger_faster" xml:space="preserve">
    <value>(più è grande, più è veloce)</value>
  </data>
  <data name="browse_for_part" xml:space="preserve">
    <value>Sfoglia la parte del file</value>
  </data>
  <data name="busy" xml:space="preserve">
    <value>Occupato</value>
  </data>
  <data name="create_dictionary" xml:space="preserve">
    <value>Directory inesistente. Vuoi crearla?</value>
  </data>
  <data name="custom" xml:space="preserve">
    <value>Personalizzato</value>
  </data>
  <data name="data_size_splits_after" xml:space="preserve">
    <value>Dimensioni dei dati nei quali avviene la divisione dopo</value>
  </data>
  <data name="debug_vars" xml:space="preserve">
    <value>Debug variabili</value>
  </data>
  <data name="delete_pieces" xml:space="preserve">
    <value>Elimina pezzi e file eseguibili dopo l'unione</value>
  </data>
  <data name="doselect_join_file" xml:space="preserve">
    <value>Vuoi selezionare il file .Join?</value>
  </data>
  <data name="do_events" xml:space="preserve">
    <value>Esegui gli eventi anche ogni</value>
  </data>
  <data name="do_events_also" xml:space="preserve">
    <value>Esegui gli eventi anche ogni (num. di byte)</value>
  </data>
  <data name="file_joiner" xml:space="preserve">
    <value>Strumento di unione dei file</value>
  </data>
  <data name="file_name" xml:space="preserve">
    <value>Nome file</value>
  </data>
  <data name="file_size" xml:space="preserve">
    <value>Dimensione file</value>
  </data>
  <data name="file_size_changed" xml:space="preserve">
    <value>La dimensione del file è stata modificata</value>
  </data>
  <data name="file_splitter" xml:space="preserve">
    <value>Strumento di divisione dei file</value>
  </data>
  <data name="file_splitter_joiner" xml:space="preserve">
    <value>Dividi e unisci</value>
  </data>
  <data name="file_splitter_joiner_title" xml:space="preserve">
    <value>Dividi e unisci</value>
  </data>
  <data name="HelpUrl" xml:space="preserve">
    <value>http://it.freemium.com/company/faq/</value>
  </data>
  <data name="idle" xml:space="preserve">
    <value>Inattivo</value>
  </data>
  <data name="invalid_path" xml:space="preserve">
    <value>Percorso non valido</value>
  </data>
  <data name="joined" xml:space="preserve">
    <value>Unione riuscita</value>
  </data>
  <data name="joining_info" xml:space="preserve">
    <value>Informazioni di unione (contenuto file .Join)</value>
  </data>
  <data name="join_file" xml:space="preserve">
    <value>Unisci file</value>
  </data>
  <data name="join_interrupted" xml:space="preserve">
    <value>Collegamento interrotto. Impossibile continuare!</value>
  </data>
  <data name="may_not_respond" xml:space="preserve">
    <value>(l'applicazione potrebbe non rispondere a lungo se il valore è troppo grande)</value>
  </data>
  <data name="min_parts_count" xml:space="preserve">
    <value>Almeno 2 parti di file da riunire</value>
  </data>
  <data name="not_enough_disk_space" xml:space="preserve">
    <value>Spazio di memoria insufficiente. Utilizzare un'altra cartella.</value>
  </data>
  <data name="not_join_file" xml:space="preserve">
    <value>Non è un file .Join</value>
  </data>
  <data name="num_of_files" xml:space="preserve">
    <value>Numero di file nei quali verrà diviso il file</value>
  </data>
  <data name="num_of_pieces" xml:space="preserve">
    <value>Numero di pezzi</value>
  </data>
  <data name="num_pieces" xml:space="preserve">
    <value>Num. di pezzi</value>
  </data>
  <data name="ok" xml:space="preserve">
    <value>OK</value>
  </data>
  <data name="options" xml:space="preserve">
    <value>Opzioni</value>
  </data>
  <data name="overwrite_confirm" xml:space="preserve">
    <value>Esiste già un file con lo stesso nome del file unito. Sovrascrivere definitivamente questo file?</value>
  </data>
  <data name="part_not_found" xml:space="preserve">
    <value>Manca una parte del file. Impossibile continuare!</value>
  </data>
  <data name="part_num" xml:space="preserve">
    <value>Parte num.</value>
  </data>
  <data name="pause" xml:space="preserve">
    <value>Pausa</value>
  </data>
  <data name="paused" xml:space="preserve">
    <value>In pausa</value>
  </data>
  <data name="pause_resume" xml:space="preserve">
    <value>Riprendi dopo pausa</value>
  </data>
  <data name="pieces_deleted" xml:space="preserve">
    <value>I pezzi sono stati eliminati</value>
  </data>
  <data name="piece_size" xml:space="preserve">
    <value>Dimensione pezzo</value>
  </data>
  <data name="refreshes_piece" xml:space="preserve">
    <value>Aggiornamenti in un pezzo</value>
  </data>
  <data name="refresh_debug_info" xml:space="preserve">
    <value>Aggiorna informazioni di debug</value>
  </data>
  <data name="refresh_num" xml:space="preserve">
    <value>Num. aggiornamento</value>
  </data>
  <data name="resume" xml:space="preserve">
    <value>Riprendi</value>
  </data>
  <data name="s360_min" xml:space="preserve">
    <value>360 KB (minimo)</value>
  </data>
  <data name="save_joined_file" xml:space="preserve">
    <value>Salva il file unito in una cartella</value>
  </data>
  <data name="save_pieces" xml:space="preserve">
    <value>Salva i pezzi nella cartella</value>
  </data>
  <data name="select_create_folder" xml:space="preserve">
    <value>Seleziona o crea la cartella per memorizzare i file divisi</value>
  </data>
  <data name="select_create_folder_join" xml:space="preserve">
    <value>Seleziona o crea la cartella per memorizzare i file uniti</value>
  </data>
  <data name="select_file_split" xml:space="preserve">
    <value>Seleziona file da dividere</value>
  </data>
  <data name="select_join_file" xml:space="preserve">
    <value>Seleziona file .Join</value>
  </data>
  <data name="select_split" xml:space="preserve">
    <value>Vuoi selezionare un file da dividere?</value>
  </data>
  <data name="self_joining_created" xml:space="preserve">
    <value>L'eseguibile self-join è stato creato</value>
  </data>
  <data name="specify_parts" xml:space="preserve">
    <value>Specifica in quante parti desideri dividerlo</value>
  </data>
  <data name="specify_piece_size" xml:space="preserve">
    <value>Specifica dimensione pezzo</value>
  </data>
  <data name="splitted" xml:space="preserve">
    <value>Divisione riuscita</value>
  </data>
  <data name="split_file" xml:space="preserve">
    <value>Dividi file</value>
  </data>
  <data name="split_info" xml:space="preserve">
    <value>Informazioni di divisione</value>
  </data>
  <data name="split_interrupted" xml:space="preserve">
    <value>Separazione interrotta. Impossibile continuare!</value>
  </data>
  <data name="stream_reader" xml:space="preserve">
    <value>lettore di flusso non chiuso</value>
  </data>
  <data name="stream_writer" xml:space="preserve">
    <value>scrittore di flusso non chiuso</value>
  </data>
  <data name="too_large" xml:space="preserve">
    <value>La dimensione della parte specificata è troppo grande per la divisione. Specificare una dimensione più piccola per la parte</value>
  </data>
</root>